TITLE:: Notator
summary:: musicXML Writer with the rewrite feature of the given sclang code to play it via scserver
categories:: Notator
related:: Reference/ScoreGuideline, Classes/PitchClassSet, Classes/SPN

DESCRIPTION::
Using the link::Classes/Notator:: class, you can play the score via the sc-server and create musicXML files to seamlessly edit the score created in sclang in your favourite music notation software that supports musicXML 4.0 (or higher) import. It provides the following automated functions:
numberedlist::
##export a musicXML file and automatically open it in a music notation program,
##create an SCD file and automatically load and open it to play music:
list::
##all standard and abbreviated notation is rewritten;
##adds a new code block to play the transcribed code;
##tied notes and articulation are applied for playback;
##tries to associate the staff label with the same name as code::SynthDef::. code::Synth(\default):: will be used if the same defname is not found with the staff label.
::
::

You can print (or make a PDF of) the musicXML file without editing it, but you should edit and modify the score, since the link::Classes/Notator:: class is not intended for engraving music, but for composing seamlessly from music designed with SuperCollider.

note::
The musical notation for the link::Classes/Notator:: class can be opened as a form of score in any music software program that supports musicXML 4.0 (or higher) import and a score view functionality.
The scores used in the examples in this help document are encoded by Dorico 4 Pro for some examples that do not display the musicXML file correctly, but are otherwise encoded by MuseScore 4.
::

warning::
The way musicXML is decoded varies from software to software, so a musicXML file may look different in different software that opens it. Also, if the decoding is not correct, the score may look incorrect. You should therefore be familiar with the musicXML import characteristics of the software you use.
::

This section covers only the basic usage of the link::Classes/Notator::.
For details, refer to link::Reference/ScoreGuideline::. For simpler and eleganter examples using algorithmic code construction, refer to the following examples in link::#examples#Example:: section:

list::
##link::#Eighth-tone Scale through algorithmic construction::
##link::#Twelve-tone matrix through algorithmic construction::
::


subsection::Basic use

The musical notation for the link::Classes/Notator:: class is constructed as an array instance, each element of which represents the contents of a particular bar. The first element of the array instance, i.e. index 0 of the array instance, is assigned information about the title, composer and copyright of the piece, and the index of the first and subsequent bar contents starts from index 1. The voice number can vary from bar to bar, but the voice number of joined notes (or joined chords) by a tie across the bar line should be the same voice. The bar number and the index of the array instance are therefore identical.
The basic usage of link::Classes/Notator:: is as follows:

table::

##
Standard

Notation

soft:: ::

soft:: ::

(Array-

in-

Array

Notation)

||
code::
(
var title, score;

title = ''; // title of the piece.
// The value for the variable title should start with a lowercase character and
// cannot be an uppercase letter or number.

score = [
	(  title: \x, composer: \x, rights: '©'  ),
	// –––––––––  ––––––––––––  –––––––––––
	// |          |             |
	// title      composer      copyrights
	//
	//             staff lable
	//             |
	//             ––––––––––––––––
	(  bar: 1, p1:(lbl: \staffLabel, atr: (...), v1:[...], v2: [...], ...), p2:(...), ...  ),
	// ––––––  –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ––––––––  –––
	// |       |                                                            |         |
	// |       contents for player 1                                        |         and so on
	// |                                                                    |
	// bar number                                                           contents for player 2
	//
	(  bar: 2, p1:(atr: (...), v1: [...], v2: [...], ...), p2:(...), ...  ),
	//             ––––––––––  –––––––––  –––––––––  –––
	//             |           |          |          |
	//             |           |          |          and so on
	//             |           |          |
	//             |           |          v2: the entries of voice 2
	//             |           |
	//             |           v1: the entries of voice 1
	//             |
	//             attributes: key signature, time signature, number of staves, clef(s)
	//
	...
];
x = Notator.notate(score, ("~/Downloads/" ++ title ++ ".musicXML").standardizePath, 'Dorico 4')
//                 –––––   –––––––––––––     –––––    ––––––––––– ––––––––––––––––  ––––––––––
//                 |       |                 |        |           |                 |
//                 |       |                 |        |           |                 the application
//                 |       |                 |        |           |                 that will open
//                 |       |                 |        |           |                 the exported
//                 |       |                 |        |           |                 musicXML file
//                 |       |                 |        |           |
//                 |       |                 |        |         standardise the path written in
//                 |       |                 |        |         a folder under the user's home folder
//                 |       |                 |        |           (starting with the ~ symbol).
//                 |       |                 |        |
//                 |       |                 |        the extension for the musicXML file
//                 |       |                 |
//                 |       |                 title of the piece above
//                 |       |
//                 |       the folder where the musicXML file will be saved
//                 |
//                 score constructed above
)
::
##
Syntactic

Sugar
||
code::
(
var title = \x;
x = [
	(  title: \x, composer: \x, rights: '©'  ),
	(  bar: 1, p1:(lbl: \staffLabel, atr: (...), v1:[...], v2: [...], ...), p2:(...), ...  ),
	(  bar: 2, p1:(lbl: \staffLabel, atr: (...), v1: [...], v2: [...], ...), p2:(...), ...  ),
	...
]
.notate(("~/Downloads/" ++ title ++ ".musicXML").standardizePath, 'Dorico 4')
)
::
##
Access

to

results
||
list::
##To play the music again via the scserver without having to recreate the music XML file:

code::
~play.()
::

##To open the musicXML file using the system's default application:

code::
x[0].openOS
::

##To reload the SCD file in SuperCollider:
code::
x[1].load
::

##To reopen the SCD file into SuperCollider:
code::
x[1].openDocument
::

##To open the folder containing the musicXML and SCD file using File Explorer (or Finder):

code::
x[0].dirname.openOS // x[1].dirname.openOS
::
::
::

There are three ways of notating musical information for link::Classes/Notator::, i.e. score construction using:

numberedlist::
##Array-in-Array Notation:

an array for each musical entry.

##Symbol-in-Array Notation:

a string or symbol for each musical entry.

##String Notation:

a string for the musical entry of a voice.
::

There would be many possibilties of playing the score according to the characteristic of music and the work style of users. In this help document, the simplest way which provided by the link::Classes/Notator:: class is provided.




subsection::Example

table::

##In this examples, Dorico 4 is used to open musicXML since MuseScore does not correctly show nested tuplets in the bar 2.

table::

##The

desired

score
||
table::
##image::resources/example 1.svg::
::
##Array

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Array-

in-

Array

Notation)
||

code::
(
var title = \ex_1, score;
score = [
	(
		title: title, composer: 'me', rights: '©'
	),
	(
		bar: 1,
		p1: (
			lbl: \test,
			atr: (key: [-3, \minor], time: [4, 4], staves: 1, clef: [[\g, 2]]),
			//                                    –––––––––
			//                                    |
			//                                    The number of staves defined in the first
			//                                    bar is fixed until the end.
			//
			v1:
			[[\t,\q,90],[\F],[\e5],[[\d,\f],$~],[$|,\x,$`],[[72,\ef]],[[71,74],\e,\sf],[\r,\q]],
			//–– –––––   ––   –––   |–––––  ––   –– –– ––    ––––––     –––––      –––  ––
			// |  |       |    |    | |  |  |    |  |  |     |   |      |          |    |
			// |  |       |    |    | |  |  tie  |  |  |     |   |      |          |    rest
			// |  |       |    |    | |  | start |  |  |     |   |      |          |
			// |  |       |    |    | |  |       |  |  |     |   |      |          sforzando
			// |  |       |    |    | |  |       |  |  |     |   |      |
			// |  |       |    |    | |  |       |  |  |     |   |      pitches for chord
			// |  |       |    |    | |  |       |  |  |     |   |
			// |  |       |    |    | |  |       |  |  |     MIDI pitch number and pitch name
			// |  |       |    |    | |  |       |  |  |     for chord with the previous
			// |  |       |    |    | |  |       |  |  |     rhythmic value
			// |  |       |    |    | |  |       |  |  |
			// |  |       |    |    | |  |       |  |  tie end
			// |  |       |    |    | |  |       |  |
			// |  |       |    |    | |  |       |  rhythmic value
			// |  |       |    |    | |  |       |  - \x: sixteenth note
			// |  |       |    |    | |  |       |  - \e: eighth note
			// |  |       |    |    | |  |       |  - \q: quarter note
			// |  |       |    |    | |  |       |  - \h: half note
			// |  |       |    |    | |  |       |
			// |  |       |    |    | |  |       the same pitch(es)
			// |  |       |    |    | |  |       as the pitch(es) of the previous entry
			// |  |       |    |    | |  |
			// |  |       |    |    | pitches for chord:
			// |  |       |    |    | the octave of previous pitch will be used.
			// |  |       |    |    | If the previous one is a chord,
			// |  |       |    |    | the octave of the last notated element in its array
			// |  |       |    |    | will be used.
			// |  |       |    |    |
			// |  |       |    |    [ ]: chord
			// |  |       |    |
			// |  |       |    pitch (scientific pitch notation)
			// |  |       |    with default rhythmic value (quarter note)
			// |  |       |
			// |  |       \F: dynamic.
			// |  |       \f: pitch class.
			// |  |
			// |  90: bpm (quarter note)
			// |
			// \t: tempo
			//
			v2: [[\c4, \dq, $(], [\b3, \e], [60, $)], [[55, \d4], \sf], [\r], [\g, \pp, $!]]
			//         –––  ––                   ––                                –––  ––
			//         |    |                    |                                 |    |
			//         |    slur start           slur end                      dynamic  |
			//         dotted quarter note                                              |
			//         dotted quarter note                                         staccatissimo
		)
	),
	(
		bar: 2,
		p1: (
			v1: [[\r, \q], [\c, \h, \p], [\b4, \q]],
			v2: [
				//                         rhythmic value and tuplet unit are the same
				//                         when there are three elements for a tuplet
				//                         |
				//         staccato        |
				// tenuto      |    tuplet |  three in place of two    nested tuplet
				//   |         |         | |  |                        |
				//   ——        ––        – –– ––––                     ––
				[\c, $-], [\d, $.], [\e, [\e, 3, 2]], [\f, [\e]], [\g, [[\x, 3, 2]]],
				[\f, [[\x]]], [\e, [[\x, \], \]], [\d, \h]
				//                       ––  ––
				//                       |   |
				//                       |   the end of the tuplet
				//                       |
				//                       the end of the nested tuplet
			]
		)
	)
];
x = Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
##Symbol

(or string)

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Symbol-

in-

Array

Notation)
||

code::
(
var title = \ex_1, score;
score = [
	(
		title: title, composer: 'me', rights: '©'
	),
	(
		bar: 1,
		p1: (
			lbl: \test,
			atr: (key: [-3, \minor], time: [4, 4], staves: 1, clef: [[\g, 2]]),
			v1: ['t q 90', \F, \e5, '<d f> ~', '| 16 `', '<72 ef>', '<71 74> 8 sf', 'r 4'],
			//                       –––––        ––      –––––––    ––––––– –         –
			//                       |            |       |          |       |         |
			//                       chord        |      chord      chord    |   rhythmic value:
			//                                    |                          |   quarter note
			//                                    |                          |
			//                                    rhythmic value:      rhythmic value:
			//                                    sixteenth note       eighth note

			v2: ["c4 4. (", "b3 8", "60 )", "<55 d4> sf", \r, 'g pp !']
			//                                                   |
			//                                                   dynamic
		)
	),
	(
		bar: 2,
		p1: (
			v1: ["r 4", "c 2 p", "b4 4"],
			v2: [
				"c -", "d .", "e /8/3:2", "f /8", "g //16/3:2", 'f //16', 'e //16//', 'd 2'
			]
		)
	)
];
x = Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
##String

soft:: ::

per

soft:: ::

Whole

Entries

per

Voice

soft:: ::

soft:: ::

(String Notation)
||
code::
(
var title = \ex_1, score;
score = [
	(
		title: title, composer: 'me', rights: '©'
	),
	(
		bar: 1,
		p1: (
			lbl: \test,
			atr: (key: [-3, \minor], time: [4, 4], staves: 1, clef: [[\g, 2]]),
			v1: "t_q_90 F e5 <d_f>_~ |_16_` <72_ef> <71_74>_8_sf r_4",
			v2: "c4_4._( b3_8 60_) <55_d4>_sf r g_pp_!"
		)
	),
	(
		bar: 2,
		p1: (
			v1: "r_q c_h_p b4_q",
			v2: "c_- d_. e_/8/3:2 f_/8 g_//16/3:2 f_//16 e_//16// d_2"
		)
	)
];
x = Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
##Automatic

rewrite of

the

sclang

code

to play

in SC
||
code::
(
~ex_1 = ( // score start
	'test': ( // part start
		1: ( // bar 1 start
			v1: [ // voice start
				(tempo: (beatUnit: \quarter, beatUnitNumDot: 0, bpm: 90)),
				(tempoNormalised: (beatUnit: \quarter, bpm: 90.0)),
				(dynamicForPart: \f),
				(
					dur: 1.0,
					midinote: [76.0], pitch: ['e5'],
					dynamic: \f, velocity: 79,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 1.0,
					midinote: [74.0, 77.0], pitch: ['d5', 'f5'],
					dynamic: \f, velocity: 79,
					articulation: 'nil', tie: \start, slur: nil
				),
				(
					dur: 0.25,
					midinote: [74.0, 77.0], pitch: ['d5', 'f5'],
					dynamic: \f, velocity: 79,
					articulation: 'nil', tie: \stop, slur: nil
				),
				(
					dur: 0.25,
					midinote: [72.0, 75.0], pitch: ['c5', 'ef5'],
					dynamic: \f, velocity: 79,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.5,
					midinote: [71.0, 74.0], pitch: ['b4', 'd5'],
					dynamic: \sf, velocity: 96,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 1.0,
					midinote: Rest(1.0), pitch: Rest(1.0),
					dynamic: \sf, velocity: 96,
					articulation: 'nil', tie: nil, slur: nil
				),
			], // voice end
			v2: [ // voice start
				(
					dur: 1.5,
					midinote: [60.0], pitch: ['c4'],
					dynamic: \mp, velocity: 55,
					articulation: 'nil', tie: nil, slur: \start
				),
				(
					dur: 0.5,
					midinote: [59.0], pitch: ['b3'],
					dynamic: \mp, velocity: 55,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.5,
					midinote: [60.0], pitch: ['c4'],
					dynamic: \mp, velocity: 55,
					articulation: 'nil', tie: nil, slur: \stop
				),
				(
					dur: 0.5,
					midinote: [55.0, 62.0], pitch: ['g3', 'd4'],
					dynamic: \sf, velocity: 96,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.5,
					midinote: Rest(0.5), pitch: Rest(0.5),
					dynamic: \sf, velocity: 96,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.5,
					midinote: [67.0], pitch: ['g4'],
					dynamic: \pp, velocity: 31,
					articulation: 'staccatissimo', tie: nil, slur: nil
				),
			] // voice end
		), // bar end
		2: ( // bar 2 start
			v1: [ // voice start
				(
					dur: 1.0,
					midinote: Rest(1.0), pitch: Rest(1.0),
					dynamic: \sf, velocity: 96,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 2.0,
					midinote: [72.0], pitch: ['c5'],
					dynamic: \p, velocity: 43,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 1.0,
					midinote: [71.0], pitch: ['b4'],
					dynamic: \p, velocity: 43,
					articulation: 'nil', tie: nil, slur: nil
				),
			], // voice end
			v2: [ // voice start
				(
					dur: 0.5,
					midinote: [60.0], pitch: ['c4'],
					dynamic: \pp, velocity: 31,
					articulation: 'tenuto', tie: nil, slur: nil
				),
				(
					dur: 0.5,
					midinote: [62.0], pitch: ['d4'],
					dynamic: \pp, velocity: 31,
					articulation: 'staccato', tie: nil, slur: nil
				),
				(
					dur: 0.33333333333333,
					midinote: [64.0], pitch: ['e4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.33333333333333,
					midinote: [65.0], pitch: ['f4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.11111111111111,
					midinote: [67.0], pitch: ['g4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.11111111111111,
					midinote: [65.0], pitch: ['f4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 0.11111111111111,
					midinote: [64.0], pitch: ['e4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
				(
					dur: 2.0,
					midinote: [62.0], pitch: ['d4'],
					dynamic: \pp, velocity: 31,
					articulation: 'nil', tie: nil, slur: nil
				),
			] // voice end
		) // bar end
	) // part end
); // score end

~play = {
	s.waitForBoot {
		var parts, numBar, detectNumVoices, eventPlayer;
		parts = [ 'test' ];
		numBar = 2;
		detectNumVoices = { |nthBar, thisPart|
			~ex_1[thisPart][nthBar].keys.count { |item|
				item.asString.contains("v") }
		};
		eventPlayer = { |thisEntry, slur, instrument|
			var articuletionToVelocity, articuletionToLegato, tiedNoteVelocity, sustain;
			articuletionToVelocity = 0;
			case
			{ thisEntry[\articulation] == 'accent'          } { articuletionToVelocity = 4    }
			{ thisEntry[\articulation] == 'strong-accent'   } { articuletionToVelocity = 8    }
			{ thisEntry[\articulation] == 'staccato'        } { articuletionToLegato   = 0.5  }
			{ thisEntry[\articulation] == 'staccatissimo'   } { articuletionToLegato   = 0.25 }
			{ thisEntry[\articulation] == 'tenuto'          } { articuletionToLegato   = 1    }
			{ thisEntry[\articulation] == 'detached-legato' } { articuletionToLegato   = 0.7  }
			{ thisEntry[\articulation] == 'nil'             } {
				articuletionToLegato   = 1;
				articuletionToVelocity = 0
			};

			articuletionToLegato = if (slur == \on || (thisEntry[\tiedDur] != 0)) {1.01} {0.8};
			tiedNoteVelocity = if (thisEntry[\tie] == \stop) { 0 } { 1 };
			tiedNoteVelocity = if (thisEntry[\tie] == \stop) { 0 } { 1 };
			sustain = if (thisEntry['tiedDur'] != 0) {
				thisEntry['tiedDur']
			} {
				thisEntry['dur']
			};
			(
				instrument: instrument,
				dur:        if (thisEntry[\tiedDur] == 0) {
					thisEntry[\dur]
				} {
					thisEntry[\tiedDur]
				},
				amp:        thisEntry[\velocity] / 127 * tiedNoteVelocity,
				midinote:   thisEntry[\midinote],
				sustain:    sustain,
				legato:     if (thisEntry[\tiedDur] == 0) {
					thisEntry[\dur]
				} {
					thisEntry[\tiedDur]
				} * articuletionToLegato
			).play.postln;
			"".postln;
		};

		parts.do { |aPart|
			var nthBar, instrument, scorePlay;
			nthBar = 1;
			instrument = if (SynthDescLib.global.synthDescs.keys.includes(aPart)) {
				aPart
			} {
				\default
			};
			scorePlay = { |nthBarNum|
				var thisPartThisBarVoiceSize = detectNumVoices.(nthBarNum, aPart);
				("bar:" + nthBarNum).postln;
				thisPartThisBarVoiceSize.do { |thisVoiceIndex|
					fork{
						var thisPartThisBarThisVoice, thisPartThisBarThisVoiceItemSize, slur;
						thisPartThisBarThisVoice = ~ex_1

							[aPart][nthBarNum][
								("v" ++ (thisVoiceIndex + 1)).asSymbol
							];
						thisPartThisBarThisVoiceItemSize = thisPartThisBarThisVoice.size;
						thisPartThisBarThisVoiceItemSize.do { |index|
							var entry = thisPartThisBarThisVoice[index];
							("\n" ++ entry ++ "\n").postln;
							case
							{ entry.keys.includes(\tempo) } {
								TempoClock.default.tempo = entry[\tempo][\bpm] / 60;
								TempoClock.default.tempo.postln
							}
							{ thisPartThisBarThisVoice[index].keys.includes(\midinote) } {
								var tiedRhythmicValue = 0, waitTime;
								switch (entry[\slur],
									\start, { slur = \on },
									\stop, { slur = \off }
								);
								if (entry[\tie] == \start) {
									var actualiseRhythmicValue;
									actualiseRhythmicValue = { |testBar, itemIdx, testItem|
										var nextTestItem, nexttestItemIdx;
										tiedRhythmicValue = tiedRhythmicValue + testItem[\dur];
										if (itemIdx < (thisPartThisBarThisVoiceItemSize - 1)) {
											if (testItem[\tie] != \stop) {
												nexttestItemIdx = itemIdx + 1;
												nextTestItem = thisPartThisBarThisVoice
												[nexttestItemIdx];
												nextTestItem.put(\tieDurCorrection, 0);
												actualiseRhythmicValue
												.(testBar, nexttestItemIdx, nextTestItem)
											}
										} {
											if (testItem[\tie] != \stop) {
												var testNextNthBar = testBar + 1;
												nexttestItemIdx = 0;
												nextTestItem = ~ex_1
												[aPart][testNextNthBar]
												[
													(\v ++ (thisVoiceIndex + 1)).asSymbol
												][0];
												nextTestItem.put(\tieDurCorrection, 0);
												actualiseRhythmicValue
												.(testNextNthBar, nexttestItemIdx, nextTestItem)
											}
										}
									};
									actualiseRhythmicValue.(nthBarNum, index, entry);
								};
								entry.put(\tiedDur, tiedRhythmicValue);
								(
									"entry['tiedDur']:" + entry['tiedDur'] ++ ";" +
									"entry['dur']:" + entry['dur'] ++ ";" +
									"entry['tieDurCorrection']:" + entry['tieDurCorrection']
								).postln;
								eventPlayer.(entry, slur, instrument);
								waitTime = if (entry[\tieDurCorrection] != nil) {
									entry[\tieDurCorrection]
								} {
									if (entry[\tiedDur] == 0) {
										entry[\dur]
									} {
										entry[\tiedDur]
									}
								};
								(
									"thisVoiceIndex:"
									+ thisVoiceIndex + waitTime
								).postln;
 								waitTime.wait
 							};
							if (index == (thisPartThisBarThisVoice.size - 1)) {
								if (nthBar < numBar) {
									nthBar = nthBar + 1;
									scorePlay.(nthBar)
								}
							}
						}
					}
				}
			};
			scorePlay.(nthBar)
		}
	}
};
~play.()
)
::
::
::

CLASSMETHODS::

METHOD:: notate
argument:: score
A unique construction of musical notation information in the form of arrays and events.
argument:: musicXMLfilePath
Path for musicXML file
argument:: app
Application that is launched when a musicXML file is saved.


INSTANCEMETHODS::


EXAMPLES::


subsection::Eighth-tone Scale through algorithmic construction


table::
##
The

desired

score
||
image::resources\Eighth-tone_Scale.svg::
##
Array

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Array-

in-

Array

Notation)
||
code::
(
var title = "Eighth-tone Scale", score;
score = [
	(
		title: title, composer: 'a composer', rights: '©'
	),
	(
		bar: 1, p1: (
			lbl: \Violin,
			atr: (key: [0, \none], time: [4, 4], staves: 1, clef: [[\g, 2]]),
			v1: []
		)
	)
];

(0, 1/4 .. 12).mirror.clump(4).do { |notesInBar, index|
	var bar = index + 1;
	if (bar > 1) { score = score.add((bar: bar, p1: (v1: []))) };
	notesInBar.collect { |aNote|
		score[bar][\p1][\v1] = score[bar][\p1][\v1].add([aNote + 60]) }
};
Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'MuseScore 4'
)
)
::
::





subsection::Twelve-tone matrix through algorithmic construction

table::
##
A

possible

score
||
image::resources/twelve-tone_seriesnotation.svg::
##Array

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Array-

in-

Array

Notation)
||
code::
(
var title = "twelve-tone series", matrix_12tone;
matrix_12tone = { |array|
    var matrix = 12.collect { |i| array[i]; array - (array[i] % 12) };
    matrix.do { |item| item.replace(11, \e).replace(10, \t).postln }
};
matrix_12tone = matrix_12tone.((0..11).scramble) + 72;

(
	[(title: '12-tone series matrix', composer: 'randomised', rights: '©')] ++
matrix_12tone.collect { |series, index|
    if (index == 0) {
        (
            bar: index + 1,
            p1: (
                lbl: '',
                atr: (key: [0, \none], time: \x, staves: 1, clef: [[\g, 2]]),
                v1: series.collect { |aNote| [aNote, \w] }
            )
        )
    } {
        series.postln;
        (
            bar: index + 1,
            p1: (v1: series.collect { |aNote| [aNote, \w] })
        )
    }
}
).notate(("~/Downloads/" ++ title ++ ".musicXML").standardizePath, 'MuseScore 4')
)
::
::


subsection::Nested tuplets and tied notes across bars

table::

##The

desired

score
||
In this examples, Dorico 4 is used to open musicXML since MuseScore does not correctly show nested tuplets in the bar 2.
table::
##image::resources/example 2.svg::
::
##Array

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Array-

in-

Array

Notation)
||
code::
(
var title = 'nested tuplets', score;
score = [
	(
		title: title, composer: 'me', rights: '©'

	),
	(
		bar: 1,
		p1: (
			lbl: \,
			atr: (
				key: [0, \none],
				time: [4, 4],
				staves: 1,
				clef: [[\g, 2]]
			),
			v1: [
				[\t, \q, 120],
				[[\a4, \c5, \a5], [\e, 3, 2], \p, \a, \u],
				[$|, [[\x, 3, 2]], \f, \s],
				[$|, [[\e, \]], \f, \S],
				[$|, [5, \], \j],
				[$|, [\De, 6, 4, \x], \J],
				[$|, [\t], \sf, \O],
				[$|, [\x], \sf, \o],
				[$|, [4, \], \sf, \A],
				[$|, [\de, 5, 4, \x]],
				[\aqs4, [\e, \], \sf, \j],
				[$|, [\de, 3, 2, \e], \J],
				[$|, [\t, \], \s2, \j]
			]
		)
	),
	(
		bar: 2,
		p1: (
			v1: [
				[\aqs4, [\e, 3, 2], \J],
				[\s1],
				[$|, [\e]],
				[$|, [5, \]],
				[\a4, [\x, 5, 4]],
				[$|, [\x]],
				[$\\],
				[$|, [[\x, 3, 2]]],
				[$|, [[\x]]],
				[$|, [[\x, \], \]],
				[$|, \dx],
				[$|, \t],
				[$|, \Dx],
				[$|, \i],
				[$|, \Te],
				[$|, \i, \U],
			]
		)
	)
];
Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
##Symbol

(or string)

soft:: ::

per

soft:: ::

Entry

soft:: ::

soft:: ::

(Symbol-

in-

Array

Notation)
||
code::
(
var title = 'nested tuplets', score;
score = [
	(
		title: title, composer: 'me', rights: '©'
	),
	(
		bar: 1,
		p1: (
			lbl: \,
			atr: (
				key: [0, \none],
				time: [4, 4],
				staves: 1,
				clef: [[\g, 2]]
			),
			v1: [
				"t q 120",
				"<a4 c5 a5> /8/3:2 p > (",
				"| //16/3:2 f .",
				"| //8/ f !",
				"| /8/ ~",
				"| /8../6:4/x `",
				"| /32 sf _",
				"| /16 sf -",
				"| /16/ sf ^",
				"| /8./5:4/x",
				"aqs4 /e/ sf ~",
				"| /8./3:2/e `",
				"| /32/ ff ~"
			]
		)
	),
	(
		bar: 2,
		p1: (
			v1: [
				'aqs4 /8/3/2 `',
				\s1,
				'| /8',
				'| /8/',
				'a4 /16/5/4',
				'| /16',
				'\\',
				'| //16/3/2',
				'| //16',
				'| //16//',
				'| 16.',
				'| 32',
				'| 16..',
				'| 64',
				'| 8...',
				'| 64 )'
			]
		)
	)
];
Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
##String

soft:: ::

per

soft:: ::

Whole

Entries

per

Voice

soft:: ::

soft:: ::

(String Notation)
||
code::
(
var title = 'nested tuplets', score;
score = [
	(
		title: title, composer: 'me', rights: '©'
	),
	(
		bar: 1,
		p1: (
			lbl: \,
			atr: (
				key: [0, \none],
				time: [4, 4],
				staves: 1,
				clef: [[\g, 2]]
			),
			v1: "
t_q_120
<a4_c5_a5>_/e/3:2_p_>_(
|_//16/3:2_f_.
|_//8/_f_!
|_/8/_~
|_/8../6:4/16_`
|_/32_sf__
|_/16_sf_-
|_/16/_sf_^
|_/8./5:4/16
aqs4_/8/_sf_~
|_/8./3:2/8_`
|_/32/_ff_~
"
		)
	),
	(
		bar: 2,
		p1: (
			v1: "
aqs4_/8/3:2_`
s1
|_/8 |_/8/ a4_/16/5:4 |_/16 \\ |_//16/3:2 |_//16 |_//16//
|_16. |_32 |_16.. |_64 |_8... |_64_)
"
		)
	)
];
Notator.notate(
	score,
	("~/Downloads/" ++ title ++ ".musicXML").standardizePath,
	'Dorico 4'
)
)
::
::


table::

##
code::
(
/* A score should be written in bar notation as an array. */
~score1 = [

	/* The first element should be information about the composer, title and copyright. */
	// - Access: ~score1[0]
	(   title: 'untitled', composer: 'me', rights: '©'),

	/* The elements from the second to the last are musical notation events,
	and each event contains the musical information for each bar. */
	// - Access to all bars: ~score1[1..]
	// - Access to a specific bar: ~score1[barNumber]
	//                         ex.) ~score1[1]

	(   /* The notation information of a bar should be constructed as elements within an event. */
		// It contains the "bar number" with the key \bar
		// and all the parts of the bar with keys like \p1, \p2, etc:

		bar: 1,
		// - Access: ~score1[barNumber][\bar]
		//           ex.) ~score1[1][\bar]

		// ATTENTION:
		// The first bar should contain all the parts of the whole score even though
		// one or more particular parts do not appear in the first bar.

		/* Each part should be an event that contains its notation information in the bar. */
		// The value of the event key is an array containing the notation information of its part in the bar:
		p1:
		(
			lbl: \Soprano,
			// The \lbl key should contain its part name or staff label.
			// - Access: ~score1[barNumber][partNumber][\lbl]
			//           ex.) ~score1[1][\p1][\lbl]

			atr: // The \atr key should contain its attributes as an event:
			(
				key: // This defines the key signature.
				[ // ATTENTION: the order of the elements is important!
					0 // The number of sharps or flats:
					//    2:   two sharps, used for D major or B Minor
					//    1:   one sharp, used for G major or E minor
					//    0:   no sharps and no flats
					//   -1:   one flat
					//   -2:   two flats;
					,
					\none // mode:
					//         \none: atonal
					//         \C: C-major
					//         \a: A-minor
				]
				,

				time: // This defines the time signature.
				\x //       \x: senza-misura
				/*
				[ // ATTENTION: the order of the elements is important!
				4 // upper numeral (top number)
				,
				4 // lower numeral (bottom number)
				]
				*/
				,

				staves: // This defines the number of staves.
				1       // The number of staves
				,

				clef: // This defines the clef and its position on each staff.
				[ // ATTENTION: the order of the elements is important!

					// The clef definition for the first staff:
					[ // ATTENTION: the order of the elements is important!
						\c // The clef symbol:
						//    \G: g-clef
						//    \C: c-clef
						//    \F: f clef
						,
						1  // Postition on the staff:
						//    1: the bottom line
						//    5: the fifth line from the bottom
					]
				]
				/*
				,
				trans: // This defines the transposition properties of the part, if necessary.
				[
				-1 // diatonic transposition
				,
				-2 // chromatic transposition
				,
				0 // octave transposition
				]
				*/
			),

			v1: // voice 1. Its elements should be constructed as an array.
			[
				// ATTENTION:
				// 1. The order of the elements is important!
				// 2. Each element of a voice should be an array!

				[\t, \q, 120]
				// The array element with \t as the first element and a number as the second element
				// defines the tempo by the number of quarter notes per minute.
				,

				[\F],
				// The one-element array with the following symbols defines dynamic marks:
				// - \ffff, \fff, \ff, \f,  \mf, \mp, \p,  \pp, \ppp, \pppp, \sf
				// - \s4,   \s3,  \s2, \s1, \s0, \q0, \q1, \q2, \q3,  \q4

				[\c4]
				// The array containing a scientific pitch name defines the pitch of the note.
				// - S: double sharp
				// - s: sharp
				// - (n: natural) can be ommited
				// - f: flat
				// - F: double flat
				// A quarter tone could be expressed as follows:
				// - \c5:  c5 natural
				// - \cq5: a quarter-tone raised c5
				// - \cs5: c#5
				// - \cQ5: a quarter-tone raised c#5
				// Its duration follows the last duration defined with the previous note, if any.
				// If the note is the first note of the entire notation information,
				// it follows the default value (crotchet).
				// Its dynamic mark follows the last dynamic mark defined with the previous note, if it exists.
				// If the note is the first note of the whole notation information,
				// it will follow the default value (mp).
				,

				[\cn4],

				[62]
				// The array containing a number defines the pitch of the note.
				// The number should be an integer or a float with a single decimal ending in 0.5 as follows:
				// - 72   = \c5:  c5 natural
				// - 72.5 = \cq5: one quarter-tone raised c5
				// - 73   = \cs5: c#5
				// - 73.5 = \cQ5: one quarter-tone raised c#5
				// A float with a single decimal ending in 0.5 indicates a quarter tone.
				// The range of numbers supported is as follows:
				// - range: 0 ~ 127
				// Its duration and dynamic mark are the same as described above.
				,

				[[64, 64.5, \g4, \gq4]]
				// A chord (notes of equal duration) should be defined as an array.
				// Its duration and dynamic mark are the same as described above.
				,

				[67],

				[65, \w]
				// The two-element array containing a scientific pitch name followed by a duration defines
				// the pitch of the note and its duration. The following durations are ready to use:
				//
				// Durations                                  Symbols
				//
				// - double-dotted maxima:                   \Dm  \D_
				// - dotted maxima:                          \dm  \d_
				// - maxima:                                  \m   \_
				// - double-dotted longa:                    \Dl  \D0
				// - dotted longa:                           \dl  \d0
				// - longa:                                   \l   \0  0
				// - double-dotted breve:                    \Db  \D9
				// - dotted breve:                           \db  \d9
				// - breve:                                   \b   \9  9
				// - double-dotted semibreve:                \Dw  \D8
				// - dotted semibreve:                       \dw  \d8
				// - semibreve:                               \w   \8  8
				// - double-dotted minim:                    \Dh  \D7
				// - dotted minim:                           \dh  \d7
				// - minim:                                   \h   \7  7
				// - double-dotted crotchet:                 \Dq  \D6
				// - dotted crotchet:                        \dq  \d6
				// - crotchet:                                \q   \6  6
				// - double-dotted quaver:                   \De  \D5
				// - dotted quaver:                          \de  \d5
				// - quaver:                                  \e   \5  5
				// - double-dotted semiquaver:               \Dx  \D4
				// - dotted semiquaver:                      \dx  \d4
				// - semiquaver:                              \x   \4  4
				// - double-dotted demisemiquaver:           \Dt  \D3
				// - dotted demisemiquaver:                  \dt  \d3
				// - demisemiquaver:                          \t   \3  3
				// - double-dotted hemidemisemiquaver:       \Di  \D2
				// - dotted hemidemisemiquaver:              \di  \d2
				// - hemidemisemiquaver:                      \i   \2  2
				// - double-dotted semihemidemisemiquavers:  \Dn  \D1
				// - dotted semihemidemisemiquavers:         \dn  \d1
				// - semihemidemisemiquavers:                 \n   \1  1
				// - 256th:                                   '!'
				// - 512th:                                   '`'
				// - 1024th:                                  '~'
				,

				[67, \q, \f]
				// The three-element array containing a scientific pitch name followed by
				// a duration then a dynamic mark defines the pitch of the note, its duration and dynamic mark of
				// the note.
				,

				[67, \q, \s2],
				// Strong dynamic marks can be abbreviated as follows:
				// - ffff: s4
				// - fff:  s3
				// - ff:   s2
				// - f:    s1   <- to distinguish it with a stacatto symbol (s).

				[67, \q, \q3],
				// Quiet dynamic marks can be abbreviated as follows:
				// - pppp: q4
				// - ppp:  q3
				// - pp:   q2
				// - p:    q1   <- to distinguish it with a crotchet symbol (q).


				[68, \e, \pp, \A]
				// The four-element array containing a scientific pitch name followed by
				// a duration, a dynamic mark and an articulation defines the pitch of the note, its duration,
				// dynamic mark and articulation. The following articulations are ready to use:
				//
				// Articulations      Symbols
				// - accent:          \a
				// - strong-accent:   \A
				// - staccato:        \s
				// - staccatissimo:   \S
				// - tenuto:          \o
				// - detached-legato: \O
				,

				[68, \e, \s2, \a, \j]
				// The five-element array containing a scientific pitch name followed by
				// a duration, a dynamic mark, an articulation and a tie status defines the pitch of the note,
				// its duration, dynamic mark, articulation and tie status.
				// The following tie states are ready to use:
				//
				// Tie status                       Symbols
				// - tie start:                       \j <- from 'join'
				// - tie stop:                        \J
				// - laissez vibrer:                  \r <- from 'let-ring'
				// - tie stop with laissez vibrer:    \R
				,

				[68, \e, \s2, \J],

				[68, \s, \s2, \r],

				[68, \x, \j],

				[68, \e, \R],

				[68, \e, \s2, \S, \r, \u]
				// The six-element array containing a scientific pitch name followed by
				// a duration, a dynamic mark, an articulation, tie status a slur status defines
				// the pitch of the note, its duration, dynamic mark, articulation, tie status and slur status.
				// The following slur states are ready to use:
				//
				// Slur status                       Symbols
				// - slur start:                       \u <- from r in 'slur'
				// - slur stop:                        \U
				,


				[69, \p]
				// The elements of an entry can be flexibly omitted.
				// The two-element array containing a scientific pitch name followed by an dynamic mark defines
				// the pitch of the note with its dynamic mark,
				// and its duration follows the duration of the previous note
				,

				[71, \p]
				// The repetition of the dynamic mark will not be displayed on the score, except for sf.
				,

				[72, \sf],

				[73, \sf],

				[74, \pp, \A, \r]
				,

				[74, \s]
				// The two-element array containing a scientific pitch name followed by
				// an articulation defines the pitch of the note with its articulation,
				// and its duration and dynamic mark follow those of the previous note.
				,

				[$|, \S]
				// The array containing $| defines that the pitch of the note is a repetition of
				// the previous one. Its duration and length follow those of the previous note.
				,

				[[74, 75]],

				[$|, \h, \f, \O],

				[$|, \p, \o],

				[$|, \U],

				[$\\]
				// The array containing $\\ defines that the entry is a repetition of the previous entry.
				,

				[[\c5, \a4, \fs4, \ds4], \x, \f],

				[$\\, \s],

				[$\\],

				[$\\],

				[$|, \7],
			]
		),
		p2: (
			lbl: \Contralto,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\c, 3]]),
			v1: [
				[[\c5, \a4, \fs4, \ds4], \_, \ffff],
				[[\cq5, \aq4, \fQ4, \dQ4], \d_, \fff],
				[[\df5, \bf4, \g4, \e4], \D_, \ff]
			]
		),
		p3: (
			lbl: \Tenore,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\c, 4]]),
			v1: [
				[[63.5, 60.5, 57.5, 54.5], \D0, \f],
				[[64, 61, 58, 55], \d0, \mf],
				[[64.5, 61.5, 58.5, 55.5], \0, \sf]
			],
			v2: [
				[\r, \D0],
				[\r, \d0],
				[\r, \0]
			]
		),
		p4: (
			lbl: \Basso,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\f, 4]]),
			v1: [
				[\r, \D9],
				[\r, \d9],
				[\r, 9]
			],
			v2: [
				[[52, \g3], \D9, \mp],
				[[\e3, 55], \d9, \p],
				[[52.5, \gQ3], 9, \pp],
				[[\eq3, 56.5]]
			]
		),
		p5: (
			lbl: 'Clarinetto in si bemolle',
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\g, 2]], trans:[-1, -2, 0]),
			v1: [
				[72, \D8],
				[\cq5, \d8],
				[73, 8],
				[\cQ5]
			],
			v2: [
				[67, \D8],
				[\gq4, \d8],
				[68, 8],
				[\gQ4]
			]
		),
		p6: (
			lbl: 'Violino',
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\g, 2]]),
			v1: [
				[72, \D8],
				[\cq5, \d8],
				[73, 8],
				[\cQ5]
			],
			v2: [
				[67, \D8],
				[\gq4, \d8],
				[68, 8],
				[\gQ4]
			]
		),
		p7: (
			lbl: \Viola,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\c, 3]]),
			v1: [
				[\cq4, \D7, \ppp],
				[\dq4, \d7, \pppp],
				[[61.5, \dq4, \cq4], 7]
			]
		),
		p8: (
			lbl: \Violoncello,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\f, 4]]),
			v1: [
				[\c3, \D6, \f],
				[\c3, \d6, \f],
				[\c3, 6, \f]
			]
		),
		p9: (
			lbl: \Contrabass,
			atr: (key: [0, \none], time: \x, staves: 1, clef: [[\f, 4]], trans: [0, 0, -1]),
			v1: [
				[\c3, \D6, \f],
				[\c3, \d6, \f],
				[\c3, 6, \f]
			]
		),
		p10: (
			lbl: 'Piano 1',
			atr: (key: [0, \none], time: \x, staves: 2, clef: [[\g, 2], [\f, 4]]),
			v1: [
				[[\c5, \e5, \g5], \D5, \f],
				[\ef5, \d5],
				[\c5, \5],
				[$|],
				[$|, \D4],
				[$|, \d4],
				[$|, \4],
				[[\d5, 76], \D3],
				[$|, \d3],
				[$|, \3],
				[[\d4, 65, 68], \D2],
				[$|, \d2],
				[$|, \2]/*,
				[[69, 74, 88], \D1, \sf],
				[$|, \d1],
				[$|, \1],
				[$|, '!'],
				[$|, '`'],
				[$|, '~']*/
			],
			v2: [
				[\cF4, \h],
				[\cf3, \h]
			]
		),
		p11: (
			lbl: 'Piano 2',
			atr: (
				key: [0, \none],
				time: \x,
				staves: 4,
				clef: [[\g, 2, 2], [\g, 2], [\f, 4], [\f, 4, -2]]
			),
			v1: [
				[[\a7, \a6], [\e, 3, 2, \e]],
				[$|, [\e]],
				[$|, [5, \]],
				[[\af7, \as6], [\e, 3, 2, \e]],
				[$|, [[\x, 3, 2, \x]]],
				[$|, [[\x]]],
				[$|, [[\x, \]]],
				[$|, [\e, \]],
				[$|, [\e, 5, 4, \e]],
				[$|, [[\e, 3, 2, \e]]],
				[$|, [[\q, \]]],
				[$|, [\q, \]]
			],
			v2: [
				[[\a5, \a4], [\x, 5, 4, \x]],
				[$|, [\x]],
				[$|, [4]],
				[$|, [\x]],
				[$|, [4, \]],
				[[\af5, \a4], [\x, 6, 4, \x]],
				[$|, [\x]],
				[$|, [5]],
				[$|, [\x]],
				[$|, [4, \]]
			],
			v3:
			[
				[[\a3, \a2], 6]
			],
			v4: [
				[[\a1, \a0]]
			],
		)
	)
];
Notator.notate(~score1, "~/Downloads/multiple.musicXML".standardizePath, 'MuseScore 4')
)
::
::